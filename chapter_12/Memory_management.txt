1. Pages:
The kernel treats physical pages as the basic unit of memory management. Most 32-bit architectures have 4KB pages, whereas most 64-bit architectures have 8KB pages. The kernel represents every physical page with a struct page structure, it is defined in <linux/mm_types.h>. Removing two confusing unions from the definition:
====================================
struct page{
	unsigned long flags; /* stores the status of page, whether the page is dirty or whether it is locked in memory. The flags are defined in <linux/page-flags.h> */
	atomic_t _count; /* stores how many references there are to this page. _count reaches -1 means no one is using this page, so it becomes available for a new allocation.
					    Kernel code should use page_count(struct page*) to check, but this function returns 0 if this page isn't referenced. A page may be used by i) the page
						cache(in this case the mapping field points to the address_space object associated with this page); ii) private data(pointed at by private); iii) as a
						mapping in a process's page table. */
	atomic_t _mapcount;
	unsigned long private;
	struct address_space* mapping;
	pgoff_t index;
	struct list_head lru;
	void* virtual; /* indicates the page's virtual address. Normally this is simply the address of the page in virtual memory. Some memory(called high memory) is not 
					  permanently mapped in the kernel's address space. In that case this field is NULL, and the page must be dynamically mapped if needed. */
};
====================================
The important point to understand is that the page structure is associated with physical pages, not virtual pages. Therefore, what the structure describes is transient at best. Even if the data contained in the page continues to exist, it might not always be associated with the same page structure because of swapping and so on. The data structure's goal is to describe physical memory, not the data contained within. 
If the page is not free, the kernel needs to know who owns the page. Possible owners include user-space processes, dynamically allocated kernel data, static kernel code, the page cache and so on.

2. Zones:
The kernel divides pages into different zones, the kernel uses zones to group pages of similar properties. Linux has to deal with 2 shortcomings of hardware with respect to memory addressing: i) Some hardware devices can perform DMA to only certain memory addresses; ii) Some architectures can physically addressing larger amounts of memory than they can virtually address, consequently some memory is not permanently mapped into kernel address space. Linux has 4 primary memory zones:
i)   ZONE_DMA: this zone contains pages that can undergo DMA.
ii)  ZONE_DMA32: like ZONE_DMA this zone contains pages that can undergo DMA. Unlike ZONE_DMA, these pages are accessible only by 32-bit devices.
iii) ZONE_NORMAL: this zone contains normal, regularly mapped, pages.
iv)  ZONE_HIGHMEM: this zone contains "high memory", which are pages not permanently mapped into the kernel's address space.
These zones, including 2 other less notable ones, are defined in <linux/mmzone.h>. The following table lists zones on x86-32:
Zone            Description                   Physical Memory
ZONE_DMA        DMA-able pages                < 16MB
ZONE_NORMAL     Normally addressable pages    16 ~ 896MB
ZONE_HIGHMEM    Dynamically mapped pages      > 896MB
Note that the zones do not have any physical relevance but are simply logical groupings used by the kernel to keep track of pages. Although some allocations may require pages from a particular zone, other allocations may pull from multiple zones. For example, although an allocation for DMA-able memory must originate from ZONE_DMA, a normal allocation can come from ZONE_DMA, or ZONE_NORMAL, but not both; allocations cannot cross zone boundaries. The kernel prefers to satisfy normal allocations from the normal zone, but if memory goes low, the kernel can look for pages in whatever zone is available and suitable.

struct zone is defined in <linux/mmzone.h>, only 3 zones are in system, thus, only 3 of the zone structures. The lock field is a spin lock that protects the structure from concurrent access. Note that it protects just the structure and not all the pages that reside in the zone.

3. Getting pages:
All the interfaces allocate memory with page-sized granularity are declared in <linux/gfp.h>.
struct page* alloc_pages(gfp_t gfp_mask, unsigned int order);
This allocates 2^order contiguous physical pages and returns a pointer to the first page's page structure; on error it returns NULL. You can convert a given page to its logical address with:
void* page_address(struct page* page);
This function returns a pointer to the logical address of the given physical page. If you don't need the actual struct page, you can call:
unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order);
This function works the same as alloc_pages(), except that it directly returns the logical address of the first requested page. Because the pages are contiguous, the other pages simply follow from the first.
If you need only one page, use the following two functions:
struct page* alloc_page(gfp_t gfp_mask);
unsigned long __get_free_page(gfp_t gfp_mask);

• Getting zeroed pages:
If you need the returned page filled with zeros, use the following:
unsigned long get_zeroed_page(unsigned int gfp_mask); 
This function allocates a single page, zero its contents, and returns a pointer to its logical address.

• Freeing pages:
void __free_pages(struct page* page, unsigned int order);
void free_pages(unsigned long addr, unsigned int order);
void free_page(unsigned long addr);
You must be careful to free only pages you allocate. A kernel allocation can fail, and your code must check for and handle such errors. These low-level page functions are useful when you need page-sized chunks of physically contiguous pages. For more general byte-sized allocations, the kernel provides kmalloc().

4. kmalloc():
void* kmalloc(size_t size, gfp_t flags);
The function returns a pointer to a region of memory that is at least size bytes in length. The region of memory allocated is physically contiguous. On error it returns NULL.
• gfp_t flags:
Flag (gfp_t type) is defined in <linux/types.h> as unsigned int. The flags are broken into 3 categories: i) action modifiers; ii) zone modifiers; iii) types.
i)   Action modifiers: 
All the flags, action modifiers included, are declared in <linux/gfp.h>. The file <linux/slab.h> includes this header:
Flag                  Description
__GFP_WAIT            The allocator can sleep
__GFP_HIGH            The allocator can access emergency pools
__GFP_IO              The allocator can start disk I/O
__GFP_FS              The allocator can start filesystem I/O
__GFP_COLD            The allocator should use cache cold pages
__GFP_NOWARN          The allocator doesn't print failure warnings
__GFP_REPEAT          The allocator repeats the allocation if it fails, but the allocation can potentially fail (repeats once)
__GFP_NOFAIL          The allocator indefinitely repeats the allocation, the allocation cannot fail.
__GFP_NORETRY         The allocator never retries if the allocation fails.
__GFP_NOMEMALLOC      The allocator doesn't fall back on reserves.
__GFP_HARDWALL        The allocator enforces "hardwall" cpuset boundaries. 
__GFP_RECLAIMABLE     The allocator marks the pages reclaimable.
__GFP_COMP            The allocator adds compound page metadata.
Most allocations specify these modifiers but do so indirectly by way of the type flags.

ii)  Zone modifiers:
There're only 3 zone modifiers because there're only 3 zones other than ZONE_NORMAL (which is by default allocations originate, it could fulfill allocations from any zone. The kernel prefers ZONE_NORMAL to ensure that the other zones have free pages when they are needed.) 
Flag                  Description
__GFP_DMA             Allocates only from ZONE_DMA
__GFP_DMA32           Allocates only from ZONE_DMA32
__GFP_HIGHMEM         Allocates from ZONE_HIGHMEM or ZONE_NORMAL
If neither flag is specified, the kernel fulfills the allocation from either ZONE_DMA or ZONE_NORMAL, with a strong preference to satisfy the allocation from ZONE_NORMAL.
• Note that you cannot specify __GFP_HIGHMEM to either __get_free_pages() or kmalloc(). Because these both return a logical address and not a page structure. It's possible that these functions would allocate memory not currently mapped in the kernel's virtual address space, and thus doesn't have a logical address. Only alloc_pages() can allocate high memory.

iii) Type flags:
Kernel code tends to use the correct type flag, and not specify the myriad of other flags it might need. This is both simpler and less error-prone.
Flag                  Description
GFP_ATOMIC            The allocator is high priority and must not sleep. This is the flag to use in interrupt handlers, bottom halves, while holding a spin lock, and other
                      situations where you cannot sleep.
GFP_NOWAIT            Like GFP_ATOMIC, except that the call will not fallback on emergency memory pools. This increases the liklihood of the memory allocation failing.
GFP_NOIO              This allocation can block, but must not initiate disk I/O. This is the flag to use in block I/O code when you cannot cause more disk I/O, which might 
                      lead to some unpleasant recursion.
GFP_NOFS              This allocation can block and can initiate disk i/O if it must, but it will not initiate a filesystem operation. This is the flag to use in filesystem
                      code when you cannot start another filesystem operation.
GPL_KERNEL            This is a normal allocation and might block. This is the flag to use in process context when it is safe to sleep. The kernel will do whatever it has to
                      do to obtain the memory requested by the caller. This flag should be your default choice.
GFP_USER              This is a normal allocation and might block. This flag is used to allocate memory for user-space processes.
GFP_HIGHUSER          This is an allocation from ZONE_HIGHMEM and might block. This flag is used to allocate memory for user-space processes.
GFP_DMA               This is an allocation from ZONE_DMA. Device that need DMA-able memory use this flag, usually in combination with one of the preceding flags.

• Modifiers behind each type flag
Flag               Modifier flags
GFP_ATOMIC         __GFP_HIGH
GFP_NOWAIT         0
GFP_NOIO           __GFP_WAIT
GFP_NOFS           (__GFP_WAIT | __GFP_IO)
GFP_KERNEL         (__GFP_WAIT | __GFP_IO | __GFP_FS)
GFP_USER           (__GFP_WAIT | __GFP_IO | __GFP_FS)
GFP_HIGHUSER       (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HIGHMEM)
GFP_DMA            __GFP_DMA

• Which flag to use when:
Situation                            Solution
Process context, can sleep           Use GFP_KERNEL
Process context, cannot sleep        Use GFP_ATOMIC
Interrupt handler                    Use GFP_ATOMIC
Softirq, Tasklet                     Use GFP_ATOMIC
Need DMA-able memory, can sleep      Use (GFP_DMA | GFP_KERNEL)
Need DMA-able memory, cannot sleep   Use (GFP_DMA | GFP_ATOMIC)

• kfree():
void kfree(const void* ptr);
Don't call this function on memory not previously allocated with kmalloc(), or on memory that has already been freed. Note that calling kfree(NULL) is explicitly checked for and safe.

5. vmalloc():
vmalloc() works in a similar fashion to kmalloc(), except it allocates memory that is only virtually contiguous and not necessarily physically contiguous. The kmalloc() function guarantees that the pages are physically contiguous (and virtually contiguous). It implements this by allocating potentially noncontiguous chunks of physical memory and "fixing up" the page tables to map the memory into a contiguous chunk of the logical address space. 
For the most part, only hardware devices require physically contiguous memory allocation. Despite the fact that physically contiguous memory is required in only certain cases, most kernel code uses kmalloc() and not vmalloc(); primarily this is for performance. The vmalloc() function, to make nonphysically contiguous pages contiguous in the virtual address space, must specifically set up the page table entries. Worse, page obtained via vmalloc() must be mapped by their individual pages, which results in much greater TLB thrashing than you see when directly mapped memory is used. Because of these, vmalloc() is used only when absolutely - typically, to obtain large regions of memory. For example, when modules are dynamically inserted into the kernel, they are loaded into memory created via vmalloc().

void* vmalloc(unsigned long size);
This function returns a pointer to at least size bytes of virtually contiguous memory; on error it returns NULL. The function might sleep and thus cannot be called from interrupt context or other situations in which blocking is not permissible.
void vfree(const void* addr);
This function also sleeps.

6. Slab layer:

