â€¢ Block devices are hardware devices distinguished by the random access of fixed-size chunks of data. Character devices are accessed as a stream of sequential data, one byte after another. The difference comes down to whether the device accesses data randomly.
Managing block devices in the kernel requires more care and work than managing character devices. Character devices have only one position - the current one; whereas block devices must be able to navigate back and forth between any location on the media. The kernel doesn't have to provide an entire subsystem to manage character devices, but block devices definitely require that. Another reason is that block devices are quite performance sensitive.

1. Anatomy of a block device:
The smallest addressable unit on a block device is a sector (hardware view). The smallest logically addressable unit from kernel's point of view is a block. 
The block size cannot be smaller than sector size and must be a multiple of sector size. The kernel also requires that the block size be no larger than page size. (But this is an artificial constrain that could go away in the future. This constrain just simplifies the kernel.)

2. Buffers and buffer heads:
When a block is stored in memory - say, after a read or pending write - it is stored in a buffer. Each buffer is associated with exactly 1 block. The buffer serves as the object that represents a disk block in memory. A single page can hold one or more blocks in memory. Each buffer is associated with a descriptor, which is called buffer head and is defined in <linux/buffer_head.h>, of type struct buffer_head:
===========================================================================
struct buffeR_head{
	unsigned long b_state;              /* buffer state flags */
	struct buffer_head* b_this_page;    /* list of page's buffers */
	struct page* b_page;                /* associated page */
	sector_t b_blocknr;                 /* starting block number */
	size_t b_size;                      /* size of mapping */
	char* b_data;                       /* pointer to data within page */
	struct block_device* b_bdev;        /* associated block device */
	bn_end_io_t* b_end_io;              /* I/O completion */
	void* b_private;                    /* reserved for b_end io */
	struct list_head b_assoc_buffers;   /* associated mappings */
	struct address_space* b_assoc_map;  /* associated address space */
	atomic_t b_count;                   /* use count */
};
===========================================================================
b_state flag specifies the state of this particular buffer, see p292 for more details. Note that bh_state_bits enumeration's last value: BH_PrivateStart flag; it isn't a valid state of buffer, but indicates the first usable bit of which other code can make use. (All bit values equal to or greater than BH_PrivateStart are safe to be used by individual drivers who want to store information in the b_state field.)
Before manipulating a buffer head, you must increment its reference count via get_bh(); and call put_bh() when finished with the buffer head.
The physical block on disk to which a given buffer corresponds is the b_blocknr-th logical block on the block device described by b_bdev.
The physical page in memory to which a given buffers corresponds is the page pointed to by b_page. b_data is a pointer directly to the block that exists somewhere in b_page, which is b_data in size. Therefore, the block is located in memory starting at address b_data and ending at address (b_data + b_size).

The purpose of a buffer head is to describe this mapping between the on-disk block and the physical in-memory buffer (which is a sequence of bytes on a specific page). Acting as a descriptor of this disk_block-to-physical_page mapping is buffer_head's only role in kernel.


