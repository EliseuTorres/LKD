1. Interrupts, Interrupt Handlers, Top halves versus Bottom Halves:
Interrupts: Asynchronous interrupts generated by hardware; Exception: synchronous interrupts generated by the processor.
Interrupt Request (IRQ) lines: each IRQ line is assigned a numerical value.
Interrupt handlers: also called Interrupt Service Routine (ISR), the function kernel runs in response to a specific interrupt. What differentiates interrupt handlers from other kernel functions is that: kernel invokes ISR in a special context called interrupt context, also called atomic context sometimes, because code executing in this context is unable to block.
Top halves versus bottom halves: Because the 2 goals: i) ISR executes quickly; ii) ISR performs a large amount of work - conflict with each other, so the processing of interrupts is split into two parts. The interrupt handler (ISR) is the top half, the top half runs immediately on receipt of the interrupt and performs only the work that is time-crirical. Work that can be performed later is deferred until the bottom half, the bottom half runs in the future, at a more convenient time, with all interrupts enabled.

• Registering an interrupt handler:
Drivers can register an interrupt handler and enable a given interrupt line for handling with the function request_irq(), which is declared in <linux/interrupt.h>:
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char* name, void* dev);
i)   1st argu: irq specifies the interrupt number to allocate. It could be hard-coded or dynamically determined.
ii)  2nd argu: handler is a function pointer to the actual interrupt handler that services this interrupt;
typedef irqreturn_t (*irq_handler_t)(int, void*);
iii) 3rd argu: flags, defined in <linux/interrupt.h>, among all the most important ones are:
	 a) IRQF_DISABLED: if set kernel disables all interrupts when executing this interrupt handler; if unset, kernel only disables the current specific interrupt when 
	 executing that interrupt's handler.
	 b) IRQF_SAMPLE_RANDOM: This flag specifies that interrupts generated by this device should contribute to kernel entropy pool. (Kernel entropy pool provides truly random 
	 numbers derived from various random envents.) Do not set this if your device issues interrupts at a predictable rate (e.x. the system timer) or can be influenced by 
 	 external attackers (e.x. networking device)
 	 c) IRQF_TIMER: This flag specifies that this handler processes interrupts for the system timer.
	 d) IRQF_SHARED: This flag specifies that the interrupt line can be shared among multiple interrupt handlers. Each handler registered on a given line must all specify 
	 this flag; otherwise, only one handler could exist per line.
iv)  4th argu: name is the ASCII text representation of the device associated with the interrupt. These text names are used by /proc/irq and /proc/interrupts.
v)   5th argu: dev is used for shared interrupt lines. It is useful to detect the handler you wanna remove during freeing the ISR on a shared interrupt line. dev could be 
NULL if the line is not shared. This pointer is also passed into ISR on each invocation. A common practice is to pass the device driver's device structure: it is unique and might be useful in the ISR.
On success request_irq() returns 0.

Note that request_irq() can sleep, therefore cannot be called from interrupt context or other situation where code cannot block. The reason that it can sleep is that: On registration, an entry corresponding is created in /proc/irq, calls proc_mkdir() -> calls proc_create() -> calls kmalloc(), kmalloc() can sleep.

• Freeing an interrupt handler:

